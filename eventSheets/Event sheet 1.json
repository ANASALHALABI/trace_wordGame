{
	"name": "Event sheet 1",
	"events": [
		{
			"eventType": "variable",
			"name": "Level",
			"type": "number",
			"initialValue": "2",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 284559757000051
		},
		{
			"eventType": "variable",
			"name": "SvgWidth",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 418358697326174
		},
		{
			"eventType": "variable",
			"name": "SvgHeight",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 748424808583092
		},
		{
			"eventType": "variable",
			"name": "Cx",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 920151634083526
		},
		{
			"eventType": "variable",
			"name": "Cy",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 786844327869502
		},
		{
			"eventType": "variable",
			"name": "pathStroke",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 267582227182973
		},
		{
			"eventType": "variable",
			"name": "IsInDrag",
			"type": "boolean",
			"initialValue": "false",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 761447594832361
		},
		{
			"eventType": "variable",
			"name": "parX",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 291541908608882
		},
		{
			"eventType": "variable",
			"name": "parY",
			"type": "number",
			"initialValue": "0",
			"comment": "",
			"isStatic": false,
			"isConstant": false,
			"sid": 425861109658411
		},
		{
			"eventType": "block",
			"conditions": [
				{
					"id": "on-start-of-layout",
					"objectClass": "System",
					"sid": 854357542748812
				}
			],
			"actions": [
				{
					"id": "request-project-file",
					"objectClass": "AJAX",
					"sid": 853511150556027,
					"parameters": {
						"tag": "\"loadJSON\"",
						"file": "level.json"
					}
				}
			],
			"sid": 148133155465412
		},
		{
			"eventType": "block",
			"conditions": [
				{
					"id": "on-completed",
					"objectClass": "AJAX",
					"sid": 596976284472574,
					"parameters": {
						"tag": "\"loadJSON\""
					}
				}
			],
			"actions": [
				{
					"id": "parse",
					"objectClass": "JSON",
					"sid": 181186475053754,
					"parameters": {
						"data": "AJAX.LastData"
					}
				},
				{
					"callFunction": "Level_Init",
					"sid": 622794153259242
				},
				{
					"id": "wait",
					"objectClass": "System",
					"sid": 724780449450115,
					"parameters": {
						"seconds": "1.0"
					}
				},
				{
					"type": "script",
					"script": "function initializeSVG() {\n    const svgElement = document.getElementById('SvgExam');\n    svgElement.setAttribute('width', runtime.globalVars.SvgWidth);\n    svgElement.setAttribute('height', runtime.globalVars.SvgHeight);\n    svgElement.innerHTML = '';  // Clear previous SVG contents\n\n    const strokesArray = runtime.objects.StrokesArray.getFirstInstance();\n    if (strokesArray) {\n        console.log(\"Number of strokes:\", strokesArray.width);\n        animatePathSequentially(svgElement, strokesArray, 0); // Start animating paths sequentially\n    } else {\n        console.log(\"Failed to load strokes from StrokesArray.\");\n    }\n}\n\nfunction animatePathSequentially(svgElement, strokesArray, index) {\n    const pointsAnimationArray = runtime.objects.PointsAnimationArray.getFirstInstance();\n    const arrayLength = pointsAnimationArray.width;\n    let instantAppearanceIndices = [];\n    for (let i = 0; i < arrayLength; i++) {\n        instantAppearanceIndices.push(pointsAnimationArray.getAt(i));\n    }\n\n    if (index < strokesArray.width) {\n        let strokeData = strokesArray.getAt(index, 0, 0);\n\n        const newPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        newPath.setAttribute(\"d\", strokeData);\n        newPath.setAttribute(\"stroke\", \"gray\");\n        newPath.setAttribute(\"fill\", \"none\");\n        newPath.setAttribute(\"stroke-width\", runtime.globalVars.pathStroke);\n        newPath.style.strokeDasharray = newPath.getTotalLength();\n        newPath.style.strokeDashoffset = newPath.getTotalLength();\n        svgElement.appendChild(newPath);\n\n        const newFillPath = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        newFillPath.setAttribute(\"d\", strokeData);\n        newFillPath.setAttribute(\"stroke\", \"blue\");\n        newFillPath.setAttribute(\"fill\", \"none\");\n        newFillPath.setAttribute(\"stroke-width\", runtime.globalVars.pathStroke);\n        newFillPath.style.strokeDasharray = newPath.getTotalLength().toString();\n        newFillPath.style.strokeDashoffset = newPath.getTotalLength().toString();\n        newFillPath.style.display = \"none\";  // Keep the blue path hidden initially\n        svgElement.appendChild(newFillPath);\n\n        if (instantAppearanceIndices.includes(index)) {\n            // For dots, make them appear at once\n            newPath.style.strokeDashoffset = \"0\";\n            newFillPath.style.display = \"\"; // Ensure the blue path is visible\n            setTimeout(() => {\n                animatePathSequentially(svgElement, strokesArray, index + 1);\n            }, 100);\n        } else {\n            // Animate the path as usual\n            animatePathDrawing(newPath, () => {\n                // Do not display the blue path yet, only display it during interaction\n                animatePathSequentially(svgElement, strokesArray, index + 1);\n            });\n        }\n    } else {\n        // All paths have been animated or set, now add interaction elements\n        addInteractionElements(svgElement);\n    }\n}\n\n\n\nfunction animatePathDrawing(path, callback) {\n    const length = path.getTotalLength();\n    let currentOffset = length;\n    const interval = 30; // milliseconds between each small movement\n    const decrement = length / (2000 / interval); // Adjust the total duration of the animation here (2000 ms in this example)\n\n    function reduceOffset() {\n        currentOffset -= decrement;\n        if (currentOffset > 0) {\n            path.style.strokeDashoffset = currentOffset;\n            requestAnimationFrame(reduceOffset);\n        } else {\n            path.style.strokeDashoffset = 0; // Ensure it ends exactly at 0\n            callback(); // Call callback function when animation is complete\n        }\n    }\n\n    reduceOffset();\n}\n\nfunction addInteractionElements(svgElement) {\n    const dot = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    dot.setAttribute(\"id\", \"dot\");\n    dot.setAttribute(\"cx\", runtime.globalVars.Cx);\n    dot.setAttribute(\"cy\", runtime.globalVars.Cy);\n    dot.setAttribute(\"r\", \"40\");\n    dot.setAttribute(\"fill\", \"red\");\n    svgElement.appendChild(dot);\n\n    const interactionArea = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    interactionArea.setAttribute(\"id\", \"interactionArea\");\n    interactionArea.setAttribute(\"cx\", runtime.globalVars.Cx);\n    interactionArea.setAttribute(\"cy\", runtime.globalVars.Cy);\n    interactionArea.setAttribute(\"r\", \"50\");\n    interactionArea.setAttribute(\"fill\", \"transparent\");\n    interactionArea.style.cursor = 'pointer';\n    svgElement.appendChild(interactionArea);\n\n    initializeDotAndTrack(); // Initialize the dot tracking functionality after all elements are added\n}\nfunction initializeDotAndTrack() {\n    const svgElement = document.getElementById('SvgExam');\n    const dot = svgElement.querySelector('#dot');\n    const interactionArea = svgElement.querySelector('#interactionArea');\n    const paths = svgElement.querySelectorAll('path');\n    let letterPointArray = [];\n\n    // Declare variables to track state\n    let dragging = false;\n    let lastX = 0, lastY = 0;\n    let currentU = 0;\n    let accumulatedDistance = 0;\n\n    // Assuming LetterPointArray is the name of your array in Construct 3\n    const letterPoints = runtime.objects.LetterPointArray.getFirstInstance();\n    const arrayLength = letterPoints.width;  // Adjust this if using a different dimension\n    for (let i = 0; i < arrayLength; i++) {\n        letterPointArray.push(letterPoints.getAt(i));  // Adjust index access if your array is structured differently\n    }\n\n    paths.forEach((path, index) => {\n        if (index % 2 === 1) { // Assuming even indices are drawing paths, odd indices are fill paths\n            path.style.strokeDasharray = path.getTotalLength().toString();\n            path.style.strokeDashoffset = path.getTotalLength().toString();\n        }\n    });\n\n    let currentPathIndex = 0;\n    let totalLength = paths[currentPathIndex].getTotalLength();\n\n    interactionArea.addEventListener(\"click\", (event) => {\n        if (letterPointArray.includes(currentPathIndex)) {\n            // If the current path is a dot, handle click\n            handleDotClick(currentPathIndex);\n        }\n    });\n\n    interactionArea.addEventListener(\"mousedown\", startDrag);\n    interactionArea.addEventListener(\"touchstart\", startDrag);\n    document.addEventListener(\"mousemove\", moveDrag);\n    document.addEventListener(\"touchmove\", moveDrag);\n    document.addEventListener(\"mouseup\", endDrag);\n    document.addEventListener(\"touchend\", endDrag);\n\n    function handleDotClick(pathIndex) {\n        if (currentPathIndex === pathIndex) {\n            updatePosition(1); // Complete the dot interaction\n        }\n    }\n\n    function startDrag(event) {\n        if (letterPointArray.includes(currentPathIndex)) {\n            return; // Prevent dragging if current path is a dot\n        }\n\n        // Calculate distance from the interaction area center to enforce dragging only when close\n        const interactionRect = interactionArea.getBoundingClientRect();\n        const clientX = event.type === 'touchstart' ? event.touches[0].clientX : event.clientX;\n        const clientY = event.type === 'touchstart' ? event.touches[0].clientY : event.clientY;\n        const dx = clientX - (interactionRect.left + interactionRect.width / 2);\n        const dy = clientY - (interactionRect.top + interactionRect.height / 2);\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist > parseFloat(interactionArea.getAttribute('r'))) {  // Only allow dragging if the pointer is within the radius of the interaction area\n            return;\n        }\n\n        dragging = true;\n        runtime.globalVars.IsInDrag = true;  // Set IsInDrag to true when dragging starts\n        lastX = clientX;\n        lastY = clientY;\n        event.preventDefault();\n        document.body.style.cursor = \"grabbing\";\n    }\n\n    function moveDrag(event) {\n    if (!dragging || letterPointArray.includes(currentPathIndex)) return;\n\n    const clientX = event.type === 'touchmove' ? event.touches[0].clientX : event.clientX;\n    const clientY = event.type === 'touchmove' ? event.touches[0].clientY : event.clientY;\n\n    const interactionRect = interactionArea.getBoundingClientRect();\n    const interactionX = interactionRect.left + interactionRect.width / 2;\n    const interactionY = interactionRect.top + interactionRect.height / 2;\n    const dx = clientX - interactionX;\n    const dy = clientY - interactionY;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist > parseFloat(interactionArea.getAttribute('r'))) {  // Only allow dragging if the pointer is within the radius of the interaction area\n        endDrag();\n        return;\n    }\n\n    accumulatedDistance += Math.sqrt((clientX - lastX) * (clientX - lastX) + (clientY - lastY) * (clientY - lastY));\n    lastX = clientX;\n    lastY = clientY;\n\n    if (accumulatedDistance !== 0) {\n        let du = accumulatedDistance / totalLength;\n        currentU = Math.max(0, Math.min(currentU + du, 1));\n        accumulatedDistance = 0;\n        requestAnimationFrame(() => updatePosition(currentU));\n    }\n}\n\n    function updatePosition(u) {\n    const currentPath = paths[currentPathIndex];\n    let p = currentPath.getPointAtLength(u * totalLength);\n    dot.setAttribute(\"cx\", p.x);\n    dot.setAttribute(\"cy\", p.y);\n    interactionArea.setAttribute(\"cx\", p.x);\n    interactionArea.setAttribute(\"cy\", p.y);\n\n    // Show the blue path (fill path) only when the circle is moving over it\n    let correspondingFillPath = paths[currentPathIndex + 1];\n    correspondingFillPath.style.display = \"\";  // Make the fill path visible\n    correspondingFillPath.style.strokeDashoffset = totalLength * (1 - u); // Update the fill path\n\n    // Update global variables parX and parY with the new position of the dot\n    runtime.globalVars.parX = p.x;\n    runtime.globalVars.parY = p.y;\n\n    if (u === 1) {\n        moveToNextPath();\n    }\n}\n\n    function moveToNextPath() {\n        if (currentPathIndex < paths.length - 2) {\n            currentPathIndex += 2;\n            totalLength = paths[currentPathIndex].getTotalLength();\n            currentU = 0;\n            accumulatedDistance = 0;\n            moveDotToStart(paths[currentPathIndex]);\n        } else {\n            dot.style.display = \"none\"; // Hide the dot when finished\n            interactionArea.style.display = \"none\"; // Hide the interaction area\n            runtime.globalVars.IsInDrag = false;  // Set IsInDrag to false when dragging ends\n        }\n    }\n\n    function moveDotToStart(path) {\n        let p = path.getPointAtLength(0);\n        dot.setAttribute(\"cx\", p.x);\n        dot.setAttribute(\"cy\", p.y);\n        interactionArea.setAttribute(\"cx\", p.x);\n        interactionArea.setAttribute(\"cy\", p.y);\n\n        // Update global variables parX and parY with the new start position of the dot\n        runtime.globalVars.parX = p.x;\n        runtime.globalVars.parY = p.y;\n    }\n\n    function endDrag(event) {\n        dragging = false;\n        runtime.globalVars.IsInDrag = false;  // Set IsInDrag to false when dragging ends\n        document.body.style.cursor = \"default\";\n    }\n}\n\ninitializeSVG();\n"
				},
				{
					"type": "script",
					"script": "initializeDotAndTrack();",
					"disabled": true
				}
			],
			"sid": 889342124449057
		},
		{
			"functionName": "Level_Init",
			"functionDescription": "",
			"functionCategory": "",
			"functionReturnType": "none",
			"functionCopyPicked": false,
			"functionIsAsync": false,
			"functionParameters": [],
			"eventType": "function-block",
			"conditions": [],
			"actions": [],
			"sid": 517489747888875,
			"children": [
				{
					"eventType": "block",
					"conditions": [],
					"actions": [
						{
							"id": "set-path",
							"objectClass": "JSON",
							"sid": 300438305739009,
							"parameters": {
								"path": "\"levels\"&\".\"&Level"
							}
						},
						{
							"id": "set-eventvar-value",
							"objectClass": "System",
							"sid": 876880050720479,
							"parameters": {
								"variable": "SvgWidth",
								"value": "JSON.Get(JSON.Path&\".width\")"
							}
						},
						{
							"id": "set-eventvar-value",
							"objectClass": "System",
							"sid": 724490751770524,
							"parameters": {
								"variable": "SvgHeight",
								"value": "JSON.Get(JSON.Path&\".height\")"
							}
						},
						{
							"id": "set-eventvar-value",
							"objectClass": "System",
							"sid": 100012924638552,
							"parameters": {
								"variable": "pathStroke",
								"value": "JSON.Get(JSON.Path&\".pathStroke\")"
							}
						},
						{
							"id": "set-eventvar-value",
							"objectClass": "System",
							"sid": 573269263790817,
							"parameters": {
								"variable": "Cx",
								"value": "JSON.Get(JSON.Path&\".cx\")"
							}
						},
						{
							"id": "set-eventvar-value",
							"objectClass": "System",
							"sid": 422370656425006,
							"parameters": {
								"variable": "Cy",
								"value": "JSON.Get(JSON.Path&\".cy\")"
							}
						},
						{
							"id": "set-size",
							"objectClass": "StrokesArray",
							"sid": 191015201092190,
							"parameters": {
								"width": "JSON.ArraySize(\".strokes\") ",
								"height": "1",
								"depth": "1"
							}
						},
						{
							"id": "set-size",
							"objectClass": "LetterPointArray",
							"sid": 170128650078517,
							"parameters": {
								"width": "JSON.ArraySize(\".letterPoints\") ",
								"height": "1",
								"depth": "1"
							}
						},
						{
							"id": "set-size",
							"objectClass": "PointsAnimationArray",
							"sid": 808090890084845,
							"parameters": {
								"width": "JSON.ArraySize(\".pointsanimation\") ",
								"height": "1",
								"depth": "1"
							}
						}
					],
					"sid": 970089162102567
				},
				{
					"eventType": "block",
					"conditions": [
						{
							"id": "for-each",
							"objectClass": "JSON",
							"sid": 736908116595102,
							"parameters": {
								"path": "JSON.Path&(\".strokes\")"
							}
						}
					],
					"actions": [
						{
							"id": "set-at-x",
							"objectClass": "StrokesArray",
							"sid": 274292714115904,
							"parameters": {
								"x": "int(JSON.CurrentKey)",
								"value": "JSON.CurrentValue"
							}
						}
					],
					"sid": 462275638166396
				},
				{
					"eventType": "block",
					"conditions": [
						{
							"id": "for-each",
							"objectClass": "JSON",
							"sid": 409652651624646,
							"parameters": {
								"path": "JSON.Path&(\".letterPoints\")"
							}
						}
					],
					"actions": [
						{
							"id": "set-at-x",
							"objectClass": "LetterPointArray",
							"sid": 745924779628741,
							"parameters": {
								"x": "int(JSON.CurrentKey)",
								"value": "JSON.CurrentValue"
							}
						}
					],
					"sid": 365564675049747
				},
				{
					"eventType": "block",
					"conditions": [
						{
							"id": "for-each",
							"objectClass": "JSON",
							"sid": 276228649029053,
							"parameters": {
								"path": "JSON.Path&(\".pointsanimation\")"
							}
						}
					],
					"actions": [
						{
							"id": "set-at-x",
							"objectClass": "PointsAnimationArray",
							"sid": 399976900455771,
							"parameters": {
								"x": "int(JSON.CurrentKey)",
								"value": "JSON.CurrentValue"
							}
						}
					],
					"sid": 187699894812445
				}
			]
		},
		{
			"eventType": "block",
			"conditions": [
				{
					"id": "compare-boolean-eventvar",
					"objectClass": "System",
					"sid": 515126627592093,
					"parameters": {
						"variable": "IsInDrag"
					}
				}
			],
			"actions": [],
			"sid": 480048759186870,
			"children": [
				{
					"eventType": "block",
					"conditions": [
						{
							"id": "every-x-seconds",
							"objectClass": "System",
							"sid": 847539465911283,
							"parameters": {
								"interval-seconds": "0.3"
							}
						}
					],
					"actions": [
						{
							"id": "create-object",
							"objectClass": "System",
							"sid": 653412260601108,
							"parameters": {
								"object-to-create": "Particles_Sponge",
								"layer": "0",
								"x": "parX",
								"y": "parY",
								"create-hierarchy": false,
								"template-name": "\"\""
							}
						},
						{
							"id": "move-to-object",
							"objectClass": "Particles_Sponge",
							"sid": 485780169696837,
							"disabled": true,
							"parameters": {
								"where": "in-front",
								"object": "HTMLElement"
							}
						},
						{
							"id": "set-scale",
							"objectClass": "Particles_Sponge",
							"sid": 617453259676546,
							"parameters": {
								"scale": "random(0.3,1)"
							}
						},
						{
							"id": "tween-two-properties",
							"objectClass": "Particles_Sponge",
							"sid": 689865991804716,
							"behaviorType": "Tween",
							"parameters": {
								"tags": "\"scaledown\"",
								"property": "scale",
								"end-x": "0",
								"end-y": "0",
								"time": "0.5",
								"ease": "default",
								"destroy-on-complete": "yes",
								"loop": "no",
								"ping-pong": "no",
								"repeat-count": "1"
							}
						}
					],
					"sid": 704704844348368
				}
			]
		}
	],
	"sid": 264773059091828
}